# pgtyped-model

```
Not ðŸ‘ an ðŸ‘ ORM ðŸ‘ !
```

This package provides a very thin layer of additional convenience around the fantastic PgTyped library.

## Features

This library enables you to:

- Map similar structured rows of multiple queries to a unified data format (e.g. create a class instance for each row)
- Pass database connection to multiple queries at once
- Convert column names to camelCase (off by default, but built-in so you don't have to provide a custom implementation if you need it)
- Provide a custom hook to be invoked on each database query (can facilitate logging or debugging)

## Installation

Using npm

```bash
npm install pgtyped-model
```

Using yarn

```bash
yarn add pgtyped-model
```

## Usage

Assuming `Post` is one of the entities in your system:

```bash
Post
â”œâ”€â”€ Post.sql        # hand-written SQL queries
â”œâ”€â”€ Post.queries.ts # file generated by PgTyped
â””â”€â”€ index.ts        # Define & export your model here
```

`index.ts`

```typescript
// All functionality of this library is provided by one function
import {createModel} from "pgtyped-model"

// Import your generated queries
import * as queries from "./Post.queries"

// Import client or pool from pg library (make sure to share it between all models)
import {pool} from "./connection"

// This is the resulting model that exposes the same queries as the generated PgTyped file, but even better ;-)
export const PostModel = createModel({
  // These are the only required options
  connection: pool,
  queries,

  // All options below are optional and can be added when you need them.

  // Convert column names to camelCase!
  // This is disabled by default and will have no performance impact if you don't need it (in spirit with no-ORM approach).
  camelCaseColumnNames: true,

  // Map each row (e.g. to a class)
  mapRows: (row) => new Post(row),

  // This hook will be invoked on each successful query.
  // Can be used for logging or debugging.
  onQuery: async ({queryName, params, rows, mappedRows}) => {
    // Log query details to console for debugging
    console.log(`
      ${queryName}(${JSON.stringify(params)}) -> ${rows.length} rows
    `)

    // Do anything async
    await Promise.resolve(/*...*/)
  },
})
```

Use the model anywhere else in your app. Type inference works magically exactly like you'd expect.

```typescript
import {PostModel} from "../models"
import {Post, PostTopic} from "../classes"

/**
 * Reading multiple rows works as expected, the correct type
 * is inferred from `mapRows` function or from the database rows
 */
async function readMultipleArray(): Promise<Post[]> {
  return model.listPosts({pageSize: 10})
}

/**
 * Queries that do not return any data, infer to Promise<void> as expected
 */
async function deleteOne(): Promise<void> {
  return model.deletePost({postId: 1})
}

/**
 * If your query is expected to return one row or
 * no data at all, just pass `{isUnique: true}`
 */
async function readOne(): Promise<Post> {
  return model.getPost({postId: 2}, {isUnique: true})
}

/**
 * If your query returns multiple rows, but you'd like to
 * index them by a unique field, just pass the field name.
 *
 * Type inference will work for the result type
 * and even on the field name.
 */
type PostsById = {[postId: string]: Post}

async function readManyIndexed(): Promise<PostsById> {
  return model.listPosts(
    {pageSize: 10},
    {
      isUnique: true,
      groupBy: "postId",
    },
  )
}

/**
 * If however the field is not unique, just pass
 * `{isUnique: false}` and the return type will change.
 */
type PostsByTopic = {[postId: string]: Post[]}

async function readManyGrouped(): Promise<PostsByTopic> {
  return model.listPosts(
    {pageSize: 10},
    {
      isUnique: false,
      groupBy: "topic",
    },
  )
}
```
